## Общие вопросы HTML

### 1. viewport //ToDo

https://developer.mozilla.org/ru/docs/Glossary/Viewport

## Общие вопросы CSS

### 1. Способы добавления CSS на страницу?

- Внешняя таблица стилей
  ```bash
     <link rel="stylesheet" href="css/style.css">
  ```
- Внутренние стили
  ```bash
     <style>
     h2 {
     color: red;
     }
     </style>
  ```
- Встроенные стили
  ```bash
     <p style="font-weight: bold; color: red;">Обратите внимание на этот текст.</p>
  ```

### 2. Единицы измерения

- `px` – абсолютные пиксели, к которым привязаны и потому не нужны `mm`, `cm`, `pt` и `pc`. Используется для максимально конкретного и точного задания размеров.
- `em` – задаёт размер относительно шрифта родителя, используется там, где нужно упростить масштабирование компоненты.
- `rem` – задаёт размер относительно шрифта `<html>`, используется для удобства глобального масштабирования: элементы которые планируется масштабировать, задаются в `rem`, а JS меняет шрифт у `<html>`.
- `%` – относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, без него никуда, но надо знать, относительно чего он считает проценты.
- `vw`, `vh`, `vmin`, `vmax` – относительно размера окна браузера.

### 3. Значения свойства display?

Значений много, но самыми популярными являются:

- `none`
  - Блочные элементы располагаются один над другим, вертикально
  - Элемент не показывается, вообще. Как будто его и нет.
- `block`
  - Блочные элементы располагаются один над другим, вертикально
  - Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.
- `inline`
  - Элементы располагаются на той же строке, последовательно.
  - Ширина и высота элемента определяются по содержимому. Поменять их нельзя.
- `inline-block`
  - Располагается в строке.
  - Размер устанавливается по содержимому.
  - Элемент всегда прямоугольный
  - Работают свойства width/height.
- `flex`
  - Flexbox позволяет удобно управлять дочерними и родительскими элементами на странице, располагая их в необходимом порядке.

### 4. Подробнее о Flex box //ToDo

### 5. свойство Position

- `static`
  Это значение позволяет элементу находиться в обычном его состоянии, расположенном на своём месте в документе. Свойства top, right, bottom, left и z-index не применяются к данному элементу. Это значение по умолчанию.
- `relative`
  Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно себя на основе значений top, right, bottom и left. Смещение не влияет на положение любых других элементов; таким образом, пространство, заданное для элемента в макете страницы, такое же, как если бы позиция была static.

- `absolute`
  Элемент удаляется из обычного потока документов, и для элемента в макете страницы не создаётся пробела. Он расположен относительно его ближайшего относительно позиционированного предка, если таковой имеется; в противном случае он помещается относительно исходного содержащего блока. Его конечная позиция определяется значениями top, right, bottom, и left.

- `fixed`
  Элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство. Он позиционируется относительно исходного содержащего блока, установленного viewport, за исключением случаев, когда один из его предков имеет свойство transform, perspective, или filter, установленное на что-то иное, кроме none (см. CSS Transforms Spec), и в этом случае этот предок ведёт себя как содержащий блок. (Обратите внимание, что существуют несогласованности браузера с perspective и filter, способствующими содержанию формирования блоков.) Его конечная позиция определяется значениями top, right, bottom и left.

- `sticky` //ToDo
  Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока), включая элементы, связанные с таблицей, на основе значений top, right, bottom, и left. Смещение не влияет на положение любых других элементов.
  Это значение всегда создаёт новый контекст наложения. Обратите внимание, что липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при overflow равном hidden, scroll, auto или overlay), даже если тот не является ближайшим фактически прокручивающим предком. Это эффективно препятствует любому «липкому» поведению

### 6. Что такое блочная-модель?

В HTML-документе каждому элементу на странице соответствует прямоугольная область (бокс или блок). Движок рендеринга в браузере определяет размеры и положение боксов на странице, а также их свойства вроде цвета, фоновой картинки для того, чтобы отобразить их на экране.

В языке CSS есть специальная боксовая модель (также блоковая модель или блочная модель, англ. box model), которая описывает, из чего состоит бокс и какие свойства влияют на его размеры. В ней у каждого бокса есть 4 области: margin (внешние отступы), border (рамка), padding (внутренние поля), и content (контент или содержимое).

### 7. cвойство box-sizing.

По умолчанию в блоковой модели CSS ширина и высота, которую вы задаёте элементу применяется только для контента элемента. Если у элемента есть граница или внутренний отступ, то они добавляются к ширине и высоте, чтобы получить отображаемый на экране размер.

Свойство box-sizing может изменять это поведение:

`content-box` даёт стандартное поведение свойства `box-sizing`. Если вы выставите элементу ширину 100 пикселей, то ширина его контента будет 100 пикселей, а ширина границ и внутренних отступов при рендере будет добавлена к финальной ширине, делая элемент шире ста пикселей.
`border-box` говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. Обычно это упрощает работу с размерами элементов.

### 8.

### 9.

### 10.

### 11.

### 12.

---

## Общие вопросы Javascript

### 1. Типы данных в JavaScript?

На данный момент в JavaScript существует 8-мь основных типов данных:

1. `String` - строка.
2. `Number` - число (как целочисленные так и с плавающей запятой)
3. `BigInt` - число не ограниченной величины. Идентификатор BigInt это `n` на конце числа.
4. `Boolean` - булевое число, то есть `false` или `true`.
5. `Symbol` - используется для создания уникальных идентификаторов
6. `null` - специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
7. `undefined`- специальное значение, означающее, что «значение не было присвоено».
8. `Object` - это сложный тип данных, который позволяет нам хранить коллекции данных.

### 2. Разница между == и === (нестрогое/строгое равенство)?

Нестрогое просто сравнивание просто сравнивает значение. Нестрогое дополнительно сравнивает их типы.

### 3. Разница между function declaration и function expression?

`Function declaration` - Это функция созданная в основном потоке кода.
Для начала нужно указать ключевое слово `function`. Затем имя функции. В круглых скобках указывает ее аргументы, а фигурных скобах описываем ее логику.
`Function Expression` – объявление функции в контексте какого-либо выражения, например присваивания.

**Основное отличие между ними: функции, объявленные как `Function Declaration`, создаются интерпретатором до выполнения кода.**
Поэтому ее можно спокойно вызвать до объявления, и это не вызовет ошибку. Происходит это благодаря механизму который называется `hoisting` или всплытие.

### 4.Разница между null и undefined?

Оба значения означают отсутствующие данные, только `undefined` представляет собой значение по умолчанию для:

- переменной которой еще не было присвоено никого другого значения.
- функций, которая ничего не возвращает явно.
- несуществующего свойства объекта.

Если обобщить, то данное значение присваивается интерпретатором в момент выполнения скрипта.
Что же касается `null` - это явное задание отсутствующего значения, то есть когда разработчик самостоятельно определяет отсутствие каких либо данных.

### 5. Операторы «И» и «ИЛИ» (&& и ||)?

### 6. Операторы «И» и «ИЛИ» (&& и ||)?

`Hoisting` - это механизм поднятия функций или переменных в глобальную или функциональную область видимости. Это особенность движка Javascript. К переменным объявленным через `var`, а также к функциям `function declaration` можно получить доступ еще до объявления значения.

### 7. Что такое область видимости (Scope)?

Это место откуда мы имеем доступ к переменным или функциям.
В Javascript есть три вида областей видимости:

- Глобальная - переменные и функции объявленные в этой области становятся глобальными. Появляются в глобальном пространстве имен и доступны они из любого места в коде.
- Функциональная или локальная - переменные и функции объявленные внутри функции, доступны только этой функции и всем вложенным в нее функциям.
- Блочная - для переменных объявленных c помощью `let` и `const`. Такая область видимости находится внутри фигурных скобок. Переменные объявленные через `var` на такую область видимости не реагируют.

### 8. Разница между var, let и const?

- Переменные объявленные через `var` всплывают. Это значит, что если мы обратимся к переменной до момента ее инициализации, то получим просто `undefined`. В случае же с `let` и `const` мы получим ошибки.
- У них есть разные области видимости `let` и `const` ограничена блоком, а не функцией.
- Переменные объявленные через `const` невозможно переопределить.

### 9. Что такое замыкание (Closure)?

Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

### 10. Что такое Лексическое окружение (LexicalEnvironment)?

https://www.youtube.com/watch?v=GkmoRy0Kv14

В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.

Объект лексического окружения состоит из двух частей:

Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).

Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

**Один вызов – одно лексическое окружение**
Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.

И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.

### 11. Что обозначает this в JavaScript?

- **В глобальном контексте выполнения** (за пределами каких-либо функций) this ссылается на глобальный объект вне зависимости от режима (строгий или нестрогий).
- **В пределах функции** значение this зависит от того, каким образом вызвана функция:
  - в методах `this` ссылается на вызывающий его объект.
  - вне объекта `this` всегда ссылается на глобальны объект в обычном режиме и является `undefined` в строгом режиме.
  - в стрелочных функциях `this` ссылается на this внешней "нормальной функции"

### 12. Event Loop. Асинхронность JavaScript

[Лучшее объяснение в этом видео](https://www.youtube.com/watch?v=LjrtNkFIWqI&list=PLDqIkh1haws4QW9A0tAPY5YRa3Rr4CZgK&index=4)

`Event Loop` - это механизм среды выполнения `javascript`, который ожидает очистки стека вызовов, прежде чем отправлять обратные вызовы из очереди задач в стек вызовов. Как только стек очищен, цикл событий запускается и проверяет очередь задач на наличие доступных обратных вызовов. Если таковые имеются, он помещает их в стек вызовов, ждет, пока стек вызовов снова очистится, и повторяет тот же процесс.

Вызов любой функции создаёт контекст выполнения (Execution Context). При вызове вложенной функции создаётся новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack).

# interview-node-question

## 1. Что такое Node.js ?

Node.js — это опенсорсная кроссплатформенная среда выполнения для JavaScript, которая работает
на серверах. Платформа Node.js построена на базе JavaScript движка V8 от Google, который используется в
браузере Google Chrome. Данная платформа, в основном, используется для создания веб-серверов,
однако сфера её применения этим не ограничивается

## 2. Каковы преимущества использования Node.js ?

С точки зрения разработки веб-сервера узел имеет ряд преимуществ:

- Отличная производительность! Узел был разработан для оптимизации пропускной способности и масштабируемости веб-приложений и является хорошим решением для многих распространенных проблем веб-разработки (например, веб-приложений реального времени).

- Код написан на "простом старом JavaScript", что означает, что меньше времени тратится на "сдвиг контекста" между языками, когда вы пишете код как на стороне клиента, так и на стороне сервера.

- JavaScript является относительно новым языком программирования и выигрывает от улучшений в языковом дизайне по сравнению с другими традиционными языками веб-сервера (например, Python, PHP и т.д.). Многие другие новые и расширенные языки компилируются / преобразуются в JavaScript, чтобы вы могли использовать TypeScript, CoffeeScript, ClojureScript, Scala, LiveScript и т.д.

- Диспетчер пакетов узлов (NPM) предоставляет доступ к сотням тысяч пакетов, которые можно повторно использовать. Он также обладает лучшим в своем классе разрешением зависимостей, а также может использоваться для автоматизации большей части набора инструментов сборки.

- Node.js является портативным. Он доступен в Microsoft Windows, macOS, Linux, Solaris, FreeBSD, OpenBSD, WebOS и NonStop OS. Кроме того, он хорошо поддерживается многими поставщиками веб-хостинга, которые часто предоставляют специальную инфраструктуру и документацию для размещения узлов сайтов.

- У него очень активная сторонняя экосистема и сообщество разработчиков, в котором много людей, готовых помочь.

## 3. Что такое Node.js Модель процесса?

Node.js выполняется в одном процессе, а код приложения выполняется в одном потоке и, следовательно, требует меньше ресурсов, чем на других платформах. Все запросы пользователей к вашему веб-приложению будут обрабатываться одним потоком, и вся работа ввода-вывода или длительная работа выполняются асинхронно для конкретного запроса. Таким образом, этому отдельному потоку не нужно ждать завершения запроса, и он может свободно обрабатывать следующий запрос. Когда асинхронная работа ввода-вывода завершается, он обрабатывает запрос дальше и отправляет ответ.

## 4. Какие есть данные в Node.js?

Как и в JS, в узле есть две категории типов данных: примитивы и объекты.

Примитивы:

- String
- Number
- Bigint
- Boolean
- Undefined
- Null
- Symbol

Объекты:

- Function
- Array
- Buffer: Node.js включает дополнительный тип данных, называемый буфером (недоступный в JavaScript браузера). Буфер в основном используется для хранения двоичных данных при чтении из файла или получении пакетов по сети. Buffer это класс.
- другие обычные объекты

## 5. Как создать простой сервер в Node.js это возвращает "Hello Word"?

**Step 01**: Создать каталог проекта

```bash
mkdir simple-server
cd simple-server
```

**Step 02**: Инициализировать проект и связать его c npm

```bash
npm init -y
```

Это создает файл `package.json`в вашей папке с натсройками по умолчанию. Файл содержит ссылки на все пакеты NPM, которые вы загрузили в свой проект.

**Step 03**: Install Express in the myapp directory

```js
const http = require('http');
//create a server object:

http
  .createServer(function (req, res) {
    res.write('Hello World!'); //write a response to the client
    res.end(); //end the response
  })
  .listen(5000); //the server object listens on port 8080

// Console will print the message
console.log('Server running at 5000');
```

**Step 04**: Run the app

```bah
node simple-server/index.js
```

## 6. Объясните концепцию модуля URL в Node.js?

Модуль URL в Node.js парсит веб-адрес в читаемые части. Используйте `require ()`Для включения модуля:

```javascript
var url = require('url');
```

Затем анализируйте адрес с методом `url.parse()`, и он вернет объект `URL` с каждой частью адреса в качестве свойств.

```javascript
var url = require('url');
var adr = 'http://localhost:8080/default.htm?year=2021&month=september';
var q = url.parse(adr, true);

console.log(q.host); //returns 'localhost:8080'
console.log(q.pathname); //returns '/default.htm'
console.log(q.search); //returns '?year=2021&month=september'

var qdata = q.query; //returns an object: { year: 2021, month: 'september' }
console.log(qdata.month); //returns 'september'
```

## 7. Как сделать HTTP-запрос POST с помощью Node.js ?

```js
const https = require('https');

const obj = {
  userId: 1,
  id: 1,
  title: 'whatever',
  completed: false,
};

const data = JSON.stringify(obj);

const options = {
  hostname: 'jsonplaceholder.typicode.com',
  port: 443,
  path: '/todos',
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Content-Length': data.length,
  },
};

const req = https.request(options, (res) => {
  console.log(`statusCode: ${res.statusCode}`);

  res.on('data', (d) => {
    process.stdout.write(d);
  });
});

req.on('error', (error) => {
  console.error(error);
});

req.write(data);
req.end();
```

## 8. Что означает среда выполнения в Node.js?

В Node.js среда выполнения - это программный стек, отвечающий за установку кода вашей веб-службы и ее зависимостей, а также за запуск вашей службы.

Среда выполнения - это буквально просто среда, в которой работает ваше приложение. Это может быть использовано для описания как аппаратного, так и программного обеспечения, на котором запущено ваше приложение. Сколько оперативной памяти, какая версия узла, какая операционная система, сколько ядер процессора - на все это можно ссылаться, когда речь идет о среде выполнения.

## 9. Объясните использование NODE_ENV?

NODE_ENV - это переменная среды, ставшая популярной благодаря платформе веб-сервера express. Когда приложение узла запущено, оно может проверять значение переменной среды и выполнять различные действия на основе этого значения.

For example, when we work on a project and there are production and development environments. We don't need to use caching in the development env. So we set

Например, когда мы работаем над проектом и есть режимы production и development. Нам не нужно использовать кэширование в production режиме. Итак, мы установили

```bash
$ NODE_ENV=development
```

и используйте код ниже

```js
if (process.env.NODE_ENV === 'development') useCaching = false;
```

На этом, если проект работает production режиме, он будет использовать кэширование.

## 10. Какие основные модули Node.js?

Они определены в рамках Node.js источник и находятся в папке lib/, и Node.js имеет несколько модулей, скомпилированных в двоичный файл.

Основные модули всегда предпочтительно загружаются, если их идентификатор передается в `require()`. Например, `require('http')` всегда будет возвращать встроенный HTTP-модуль, даже если существует файл с таким именем.

Основные модули также могут быть идентифицированы с помощью префикса node:, и в этом случае он обходит кэш require. Например, `require('узел:http')` всегда будет возвращать встроенный HTTP-модуль, даже если есть запись `require.cache` с этим именем.

## 11. Что такое функция обратного вызова (callback) в Node.js ?

В Node.js , мы в основном используем обратные вызовы для обработки асинхронных операций, таких как выполнение любого запроса ввода—вывода, операции с базой данных или вызов API для извлечения некоторых данных. Обратный вызов позволяет нашему коду не блокироваться, когда процесс занимает много времени.

```javascript
function myNew(next) {
  console.log('Im the one who initates callback');
  next('nope', 'success');
}

myNew(function (err, res) {
  console.log('I got back from callback', err, res);
});
```

## 12. **What is callback hell in Node.js?\***

Ад обратного вызова `Callback hell` Это явление, которое поражает JavaScript разработчик, когда он пытается выполнить несколько асинхронных операций один за другим.

Асинхронная функция - это то, где некоторая внешняя активность должна выполняться до того, как результат может быть обработан; Это «асинхронный» в том смысле, что существует непредсказуемое количество времени до того, как результат станет доступным.Такие функции требуют функции обратного вызова для обработки ошибок и обрабатывать результат.

```javascript
getData(function(a){
    getMoreData(a, function(b){
        getMoreData(b, function(c){
            getMoreData(c, function(d){
	            getMoreData(d, function(e){
		            ...
		        });
	        });
        });
    });
});
```

**Техника для избежания ада обратного вызова**

1. Использование ASYNC.JS.
2. Использование Промисов
3. Используя Async-Await

## 13. ЧТо такое Promises в Node.js?

Промисы связывают обработчики с конечным значением успеха асинхронного действия или причиной сбоя. Это позволяет асинхронным методам возвращать значения, подобные синхронным методам: вместо конечного значения асинхронный метод возвращает обещание для значения в какой-то момент в будущем.

Обещания в node.js пообещал выполнить некоторую работу, а затем сделал отдельные обратные вызовы, которые будут выполняться для успеха и неудачи, а также для обработки тайм-аутов. Другой способ думать об обещаниях в node.js заключалось в том, что они были излучателями, которые могли излучать только два события: успех и ошибку.Самое замечательное в обещаниях то, что вы можете объединить их в цепочки зависимостей (выполняйте обещание C только тогда, когда обещание A и обещание B выполнены).

Основная идея обещаний заключается в том, что обещание представляет собой результат асинхронной операции. Обещание находится в одном из трех разных состояний:

ожидание (pending) - начальное состояние обещания.
выполнено (fulfilled) - состояние обещания, представляющее успешную операцию.
отклонено (rejected) - состояние обещания, представляющее неудачную операцию. Как только обещание выполнено или отклонено, оно становится неизменным (т.е. оно никогда больше не может измениться).

## 14.

## 15.

## 16.

## 17.

## 18.

## 19.

## 20.

## 21.

## 22.

## 23.

## 24.
