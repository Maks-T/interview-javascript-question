# interview-javascript-question

---

## Общие вопросы Javascript

### 1. Типы данных в JavaScript?

На данный момент в JavaScript существует 8-мь основных типов данных:

1. `String` - строка.
2. `Number` - число (как целочисленные так и с плавающей запятой)
3. `BigInt` - число не ограниченной величины. Идентификатор BigInt это `n` на конце числа.
4. `Boolean` - булевое число, то есть `false` или `true`.
5. `Symbol` - используется для создания уникальных идентификаторов
6. `null` - специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
7. `undefined`- специальное значение, означающее, что «значение не было присвоено».
8. `Object` - это сложный тип данных, который позволяет нам хранить коллекции данных.

### 2. Разница между == и === (нестрогое/строгое равенство)?

Нестрогое просто сравнивание просто сравнивает значение. Нестрогое дополнительно сравнивает их типы.

### 3. Разница между function declaration и function expression?

`Function declaration` - Это функция созданная в основном потоке кода.
Для начала нужно указать ключевое слово `function`. Затем имя функции. В круглых скобках указывает ее аргументы, а фигурных скобах описываем ее логику.
`Function Expression` – объявление функции в контексте какого-либо выражения, например присваивания.

**Основное отличие между ними: функции, объявленные как `Function Declaration`, создаются интерпретатором до выполнения кода.**
Поэтому ее можно спокойно вызвать до объявления, и это не вызовет ошибку. Происходит это благодаря механизму который называется `hoisting` или всплытие.

### 4.Разница между null и undefined?

Оба значения означают отсутствующие данные, только `undefined` представляет собой значение по умолчанию для:

- переменной которой еще не было присвоено никого другого значения.
- функций, которая ничего не возвращает явно.
- несуществующего свойства объекта.

Если обобщить, то данное значение присваивается интерпретатором в момент выполнения скрипта.
Что же касается `null` - это явное задание отсутствующего значения, то есть когда разработчик самостоятельно определяет отсутствие каких либо данных.

### 5. Операторы «И» и «ИЛИ» (&& и ||)?

### 6. Операторы «И» и «ИЛИ» (&& и ||)?

`Hoisting` - это механизм поднятия функций или переменных в глобальную или функциональную область видимости. Это особенность движка Javascript. К переменным объявленным через `var`, а также к функциям `function declaration` можно получить доступ еще до объявления значения.

### 7. Что такое область видимости (Scope)?

Это место откуда мы имеем доступ к переменным или функциям.
В Javascript есть три вида областей видимости:

- Глобальная - переменные и функции объявленные в этой области становятся глобальными. Появляются в глобальном пространстве имен и доступны они из любого места в коде.
- Функциональная или локальная - переменные и функции объявленные внутри функции, доступны только этой функции и всем вложенным в нее функциям.
- Блочная - для переменных объявленных c помощью `let` и `const`. Такая область видимости находится внутри фигурных скобок. Переменные объявленные через `var` на такую область видимости не реагируют.

### 8. Разница между var, let и const?

- Переменные объявленные через `var` всплывают. Это значит, что если мы обратимся к переменной до момента ее инициализации, то получим просто `undefined`. В случае же с `let` и `const` мы получим ошибки.
- У них есть разные области видимости `let` и `const` ограничена блоком, а не функцией.
- Переменные объявленные через `const` невозможно переопределить.

### 9. Что такое замыкание (Closure)?

Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

### 10. Что такое Лексическое окружение (LexicalEnvironment)?

https://www.youtube.com/watch?v=GkmoRy0Kv14

В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.

Объект лексического окружения состоит из двух частей:

Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).

Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

**Один вызов – одно лексическое окружение**
Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.

И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.

### 11. Что обозначает this в JavaScript?

- **В глобальном контексте выполнения** (за пределами каких-либо функций) this ссылается на глобальный объект вне зависимости от режима (строгий или нестрогий).
- **В пределах функции** значение this зависит от того, каким образом вызвана функция:
  - в методах `this` ссылается на вызывающий его объект.
  - вне объекта `this` всегда ссылается на глобальны объект в обычном режиме и является `undefined` в строгом режиме.
  - в стрелочных функциях `this` ссылается на this внешней "нормальной функции"

### 12. Event Loop. Асинхронность JavaScript

[Лучшее объяснение в этом видео](https://www.youtube.com/watch?v=LjrtNkFIWqI&list=PLDqIkh1haws4QW9A0tAPY5YRa3Rr4CZgK&index=4)

`Event Loop` - это механизм среды выполнения `javascript`, который ожидает очистки стека вызовов, прежде чем отправлять обратные вызовы из очереди задач в стек вызовов. Как только стек очищен, цикл событий запускается и проверяет очередь задач на наличие доступных обратных вызовов. Если таковые имеются, он помещает их в стек вызовов, ждет, пока стек вызовов снова очистится, и повторяет тот же процесс.

Вызов любой функции создаёт контекст выполнения (Execution Context). При вызове вложенной функции создаётся новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack).

# interview-node-question

## 1. Что такое Node.js ?

Node.js — это опенсорсная кроссплатформенная среда выполнения для JavaScript, которая работает
на серверах. Платформа Node.js построена на базе JavaScript движка V8 от Google, который используется в
браузере Google Chrome. Данная платформа, в основном, используется для создания веб-серверов,
однако сфера её применения этим не ограничивается

## 2. Каковы преимущества использования Node.js ?

С точки зрения разработки веб-сервера узел имеет ряд преимуществ:

- Отличная производительность! Узел был разработан для оптимизации пропускной способности и масштабируемости веб-приложений и является хорошим решением для многих распространенных проблем веб-разработки (например, веб-приложений реального времени).

- Код написан на "простом старом JavaScript", что означает, что меньше времени тратится на "сдвиг контекста" между языками, когда вы пишете код как на стороне клиента, так и на стороне сервера.

- JavaScript является относительно новым языком программирования и выигрывает от улучшений в языковом дизайне по сравнению с другими традиционными языками веб-сервера (например, Python, PHP и т.д.). Многие другие новые и расширенные языки компилируются / преобразуются в JavaScript, чтобы вы могли использовать TypeScript, CoffeeScript, ClojureScript, Scala, LiveScript и т.д.

- Диспетчер пакетов узлов (NPM) предоставляет доступ к сотням тысяч пакетов, которые можно повторно использовать. Он также обладает лучшим в своем классе разрешением зависимостей, а также может использоваться для автоматизации большей части набора инструментов сборки.

- Node.js является портативным. Он доступен в Microsoft Windows, macOS, Linux, Solaris, FreeBSD, OpenBSD, WebOS и NonStop OS. Кроме того, он хорошо поддерживается многими поставщиками веб-хостинга, которые часто предоставляют специальную инфраструктуру и документацию для размещения узлов сайтов.

- У него очень активная сторонняя экосистема и сообщество разработчиков, в котором много людей, готовых помочь.

## 3. Что такое Node.js Модель процесса?

Node.js выполняется в одном процессе, а код приложения выполняется в одном потоке и, следовательно, требует меньше ресурсов, чем на других платформах. Все запросы пользователей к вашему веб-приложению будут обрабатываться одним потоком, и вся работа ввода-вывода или длительная работа выполняются асинхронно для конкретного запроса. Таким образом, этому отдельному потоку не нужно ждать завершения запроса, и он может свободно обрабатывать следующий запрос. Когда асинхронная работа ввода-вывода завершается, он обрабатывает запрос дальше и отправляет ответ.

## 4. Какие есть данные в Node.js?

Как и в JS, в узле есть две категории типов данных: примитивы и объекты.

Примитивы:

- String
- Number
- Bigint
- Boolean
- Undefined
- Null
- Symbol

Объекты:

- Function
- Array
- Buffer: Node.js включает дополнительный тип данных, называемый буфером (недоступный в JavaScript браузера). Буфер в основном используется для хранения двоичных данных при чтении из файла или получении пакетов по сети. Buffer это класс.
- другие обычные объекты

## 5. Как создать простой сервер в Node.js это возвращает "Hello Word"?

**Step 01**: Создать каталог проекта

```bash
mkdir simple-server
cd simple-server
```

**Step 02**: Инициализировать проект и связать его c npm

```bash
npm init -y
```

Это создает файл `package.json`в вашей папке с натсройками по умолчанию. Файл содержит ссылки на все пакеты NPM, которые вы загрузили в свой проект.

**Step 03**: Install Express in the myapp directory

```js
const http = require('http');
//create a server object:

http
  .createServer(function (req, res) {
    res.write('Hello World!'); //write a response to the client
    res.end(); //end the response
  })
  .listen(5000); //the server object listens on port 8080

// Console will print the message
console.log('Server running at 5000');
```

**Step 04**: Run the app

```bah
node simple-server/index.js
```

## 6. Объясните концепцию модуля URL в Node.js?

Модуль URL в Node.js парсит веб-адрес в читаемые части. Используйте `require ()`Для включения модуля:

```javascript
var url = require('url');
```

Затем анализируйте адрес с методом `url.parse()`, и он вернет объект `URL` с каждой частью адреса в качестве свойств.

```javascript
var url = require('url');
var adr = 'http://localhost:8080/default.htm?year=2021&month=september';
var q = url.parse(adr, true);

console.log(q.host); //returns 'localhost:8080'
console.log(q.pathname); //returns '/default.htm'
console.log(q.search); //returns '?year=2021&month=september'

var qdata = q.query; //returns an object: { year: 2021, month: 'september' }
console.log(qdata.month); //returns 'september'
```

## 7. Как сделать HTTP-запрос POST с помощью Node.js ?

```js
const https = require('https');

const obj = {
  userId: 1,
  id: 1,
  title: 'whatever',
  completed: false,
};

const data = JSON.stringify(obj);

const options = {
  hostname: 'jsonplaceholder.typicode.com',
  port: 443,
  path: '/todos',
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Content-Length': data.length,
  },
};

const req = https.request(options, (res) => {
  console.log(`statusCode: ${res.statusCode}`);

  res.on('data', (d) => {
    process.stdout.write(d);
  });
});

req.on('error', (error) => {
  console.error(error);
});

req.write(data);
req.end();
```

## 8. Что означает среда выполнения в Node.js?

В Node.js среда выполнения - это программный стек, отвечающий за установку кода вашей веб-службы и ее зависимостей, а также за запуск вашей службы.

Среда выполнения - это буквально просто среда, в которой работает ваше приложение. Это может быть использовано для описания как аппаратного, так и программного обеспечения, на котором запущено ваше приложение. Сколько оперативной памяти, какая версия узла, какая операционная система, сколько ядер процессора - на все это можно ссылаться, когда речь идет о среде выполнения.

## 9. Объясните использование NODE_ENV?

NODE_ENV - это переменная среды, ставшая популярной благодаря платформе веб-сервера express. Когда приложение узла запущено, оно может проверять значение переменной среды и выполнять различные действия на основе этого значения.

For example, when we work on a project and there are production and development environments. We don't need to use caching in the development env. So we set

Например, когда мы работаем над проектом и есть режимы production и development. Нам не нужно использовать кэширование в production режиме. Итак, мы установили

```bash
$ NODE_ENV=development
```

и используйте код ниже

```js
if (process.env.NODE_ENV === 'development') useCaching = false;
```

На этом, если проект работает production режиме, он будет использовать кэширование.

## 10. Какие основные модули Node.js?

Они определены в рамках Node.js источник и находятся в папке lib/, и Node.js имеет несколько модулей, скомпилированных в двоичный файл.

Основные модули всегда предпочтительно загружаются, если их идентификатор передается в `require()`. Например, `require('http')` всегда будет возвращать встроенный HTTP-модуль, даже если существует файл с таким именем.

Основные модули также могут быть идентифицированы с помощью префикса node:, и в этом случае он обходит кэш require. Например, `require('узел:http')` всегда будет возвращать встроенный HTTP-модуль, даже если есть запись `require.cache` с этим именем.

## 11. Что такое функция обратного вызова (callback) в Node.js ?

В Node.js , мы в основном используем обратные вызовы для обработки асинхронных операций, таких как выполнение любого запроса ввода—вывода, операции с базой данных или вызов API для извлечения некоторых данных. Обратный вызов позволяет нашему коду не блокироваться, когда процесс занимает много времени.

```javascript
function myNew(next) {
  console.log('Im the one who initates callback');
  next('nope', 'success');
}

myNew(function (err, res) {
  console.log('I got back from callback', err, res);
});
```

## 12. **What is callback hell in Node.js?\***

Ад обратного вызова `Callback hell` Это явление, которое поражает JavaScript разработчик, когда он пытается выполнить несколько асинхронных операций один за другим.

Асинхронная функция - это то, где некоторая внешняя активность должна выполняться до того, как результат может быть обработан; Это «асинхронный» в том смысле, что существует непредсказуемое количество времени до того, как результат станет доступным.Такие функции требуют функции обратного вызова для обработки ошибок и обрабатывать результат.

```javascript
getData(function(a){
    getMoreData(a, function(b){
        getMoreData(b, function(c){
            getMoreData(c, function(d){
	            getMoreData(d, function(e){
		            ...
		        });
	        });
        });
    });
});
```

**Техника для избежания ада обратного вызова**

1. Использование ASYNC.JS.
2. Использование Промисов
3. Используя Async-Await

## 13. ЧТо такое Promises в Node.js?

Промисы связывают обработчики с конечным значением успеха асинхронного действия или причиной сбоя. Это позволяет асинхронным методам возвращать значения, подобные синхронным методам: вместо конечного значения асинхронный метод возвращает обещание для значения в какой-то момент в будущем.

Обещания в node.js пообещал выполнить некоторую работу, а затем сделал отдельные обратные вызовы, которые будут выполняться для успеха и неудачи, а также для обработки тайм-аутов. Другой способ думать об обещаниях в node.js заключалось в том, что они были излучателями, которые могли излучать только два события: успех и ошибку.Самое замечательное в обещаниях то, что вы можете объединить их в цепочки зависимостей (выполняйте обещание C только тогда, когда обещание A и обещание B выполнены).

Основная идея обещаний заключается в том, что обещание представляет собой результат асинхронной операции. Обещание находится в одном из трех разных состояний:

ожидание (pending) - начальное состояние обещания.
выполнено (fulfilled) - состояние обещания, представляющее успешную операцию.
отклонено (rejected) - состояние обещания, представляющее неудачную операцию. Как только обещание выполнено или отклонено, оно становится неизменным (т.е. оно никогда больше не может измениться).

## 14.

## 15.

## 16.

## 17.

## 18.

## 19.

## 20.

## 21.

## 22.

## 23.

## 24.

## 25.

## 26.

## 27.

## 28.

## 29.

## 30.

## 31.

## 32.

## 33.

## 34.

## 35.

## 36.

## 37.

## 38.

## 39.

## 40.

## 41.

## 42.

## 43.

## 44.

## 45.

## 46.

## 47.

## 48.

## 49.

## 50.

## 51.

## 52.

## 53.

## 54.

## 55.
