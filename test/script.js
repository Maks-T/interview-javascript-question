const data = [
  [
    [`1. Типы данных в JavaScript?`],
    [
      `На данный момент в JavaScript существует 8-мь основных типов данных:

1. String - строка.
2. Number - число (как целочисленные так и с плавающей запятой)
3. BigInt - число не ограниченной величины. Идентификатор BigInt это n на конце числа.
4. Boolean - булевое число, то есть false или true.
5. Symbol - используется для создания уникальных идентификаторов
6. null - специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
7. undefined- специальное значение, означающее, что «значение не было присвоено».
8. Object - это сложный тип данных, который позволяет нам хранить коллекции данных.
`,
    ],
  ],
  [
    [
      `2. Разница между == и === (нестрогое/строгое равенство)?
`,
    ],
    [
      `Нестрогое просто сравнивание просто сравнивает значение. Нестрогое дополнительно сравнивает их типы.
`,
    ],
  ],
  [
    [
      `3. Разница между function declaration и function expression?
`,
    ],
    [
      `Function declaration - Это функция созданная в основном потоке кода.
Для начала нужно указать ключевое слово function. Затем имя функции. В круглых скобках указывает ее аргументы, а фигурных скобах описываем ее логику.
Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.

**Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.**
Поэтому ее можно спокойно вызвать до объявления, и это не вызовет ошибку. Происходит это благодаря механизму который называется hoisting или всплытие.
`,
    ],
  ],
  [
    [
      `4.Разница между null и undefined?
`,
    ],
    [
      `Оба значения означают отсутствующие данные, только undefined представляет собой значение по умолчанию для:

- переменной которой еще не было присвоено никого другого значения.
- функций, которая ничего не возвращает явно.
- несуществующего свойства объекта.
11:10 26.05.2022
Если обобщить, то данное значение присваивается интерпретатором в момент выполнения скрипта.
Что же касается null - это явное задание отсутствующего значения, то есть когда разработчик самостоятельно определяет отсутствие каких либо данных.

`,
    ],
  ],
  [
    [
      `5. Что такое Hoisting?
`,
    ],
    [
      `Hoisting - это механизм поднятия функций или переменных в глобальную или функциональную область видимости. Это особенность движка Javascript. К переменным объявленным через var, а также к функциям function declaration можно получить доступ еще до объявления значения.
`,
    ],
  ],
  [
    [
      `6. Что такое область видимости (Scope)?
`,
    ],
    [
      `Это место откуда мы имеем доступ к переменным или функциям.
В Javascript есть три вида областей видимости:

- Глобальная - переменные и функции объявленные в этой области становятся глобальными. Появляются в глобальном пространстве имен и доступны они из любого места в коде.
- Функциональная или локальная - переменные и функции объявленные внутри функции, доступны только этой функции и всем вложенным в нее функциям.
- Блочная - для переменных объявленных c помощью let и const. Такая область видимости находится внутри фигурных скобок. Переменные объявленные через var на такую область видимости не реагируют.
`,
    ],
  ],
  [
    [`7. Разница между var, let и const?`],
    [
      `.
- Переменные объявленные через var всплывают. Это значит, что если мы обратимся к переменной до момента ее инициализации, то получим просто undefined. В случае же с let и const мы получим ошибки.
- У них есть разные области видимости let и const ограничена блоком, а не функцией.
- Переменные объявленные через const невозможно переопределить.

`,
    ],
  ],
  [
    [`8. Что такое Лексическое окружение (LexicalEnvironment)?`],
    [
      `https://www.youtube.com/watch?v=GkmoRy0Kv14

В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.

Объект лексического окружения состоит из двух частей:

Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).

Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

Переменная – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

**Один вызов – одно лексическое окружение**
Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.

И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.
`,
    ],
  ],
  [
    [
      `9. Что такое замыкание (Closure)?
`,
    ],
    [
      `Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
`,
    ],
  ],
  [
    [
      `10. Что обозначает this в JavaScript?
`,
    ],
    [
      `.
- **В глобальном контексте выполнения** (за пределами каких-либо функций) this ссылается на глобальный объект вне зависимости от режима (строгий или нестрогий).
- **В пределах функции** значение this зависит от того, каким образом вызвана функция:
  - в методах this ссылается на вызывающий его объект.
  - вне объекта this всегда ссылается на глобальны объект в обычном режиме и является undefined в строгом режиме.
  - в стрелочных функциях this ссылается на this внешней нормальной функции

`,
    ],
  ],
  [
    [
      `11. Event Loop. Асинхронность JavaScript
`,
    ],
    [
      `[Лучшее объяснение в этом видео](https://www.youtube.com/watch?v=LjrtNkFIWqI&list=PLDqIkh1haws4QW9A0tAPY5YRa3Rr4CZgK&index=4)

Event Loop - это механизм среды выполнения javascript, который ожидает очистки стека вызовов, прежде чем отправлять обратные вызовы из очереди задач в стек вызовов. Как только стек очищен, цикл событий запускается и проверяет очередь задач на наличие доступных обратных вызовов. Если таковые имеются, он помещает их в стек вызовов, ждет, пока стек вызовов снова очистится, и повторяет тот же процесс.

Вызов любой функции создаёт контекст выполнения (Execution Context). При вызове вложенной функции создаётся новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack).

`,
    ],
  ],
  [
    [
      `12. Операторы «И» и «ИЛИ» (&& и ||)?
`,
    ],
    [
      `| Логическое И (&&)     | expr1 && expr2   | (Логическое И) Возвращает операнд expr1, если он может быть преобразован в false; в противном случае возвращает операнд expr2. Таким образом, при использовании булевых величин в качестве операндов, оператор && возвращает true, если оба операнда true; в противном случае возвращает false.           |
| Логическое ИЛИ (\|\|) | expr1 \|\| expr2 | (Логическое ИЛИ) Возвращает операнд expr1, если он может быть преобразован в true; в противном случае возвращает операнд expr2. Таким образом, при использовании булевых величин в качестве операндов, оператор \|\| возвращает true, если один из операндов true; если же оба false, то возвращает false |
| Логическое НЕ (!)     | !expr            | (Логическое НЕ) Возвращает false, если операнд может быть преобразован в true; в противном случае возвращает true.  `,
    ],
  ],
  [
    [`что то такое DOM?`],
    [
      `Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.

Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
`,
    ],
  ],
  [
    [
      `что то такое BOM?
`,
    ],
    [
      `Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

Например:

- Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
- Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.

`,
    ],
  ],
  [
    [
      `что то такое CSSOM?
`,
    ],
    [
      `CSS Object Model представляет собой набор API-интерфейсов, позволяющих манипулировать CSS из JavaScript. Это очень похоже на DOM, но для CSS, а не HTML. Это позволяет пользователям динамически читать и изменять стиль CSS.
`,
    ],
  ],
  [
    [`1. Что такое HTML и для чего он используется?`],
    [
      `HTML (Hypertext Markup Language) - это код, который используется для структурирования и отображения веб-страницы и её контента.
HTML не является языком программирования; это язык разметки, и используется, чтобы сообщать браузеру, как отображать веб-страницы.`,
    ],
  ],
  [
    [`2. Что такое doctype? И для чего он используется?`],
    [
      `
<!DOCTYPE html> используется для указания типа документа.
Добавляется он всегда первой строкой HTML или XHTML документа. Служит для того, чтобы браузер мог понять как ему интерпретировать страницу. И в соответствии с каким стандартом осуществлять парсинг документа.

### 3. Опишите базовую структуру HTML-страницы?

html
<!DOCTYPE html>

<!-- корневая обертка страницы -->
<html lang=ru>
  <!-- тег который содержит все вспомогательные данные о HTML документе:
       - заголовок, описание, SEO-информация, подключение стилей и шрифтов, скриптов, meta-информация.
       Данные указанные внутри этого тега не отрисовываются на странице-->
  <head>
    <meta charset=UTF-8 />
    <title>Моя первая страница</title>
  </head>

  <!-- тег, который содержит всю разметку HTML документа. 
       Именно эта разметка будет отображаться в браузере -->
  <body></body>
</html>
`,
    ],
  ],
  [
    [`3. Опишите базовую структуру HTML-страницы?`],
    [
      `html
<!DOCTYPE html>

<!-- корневая обертка страницы -->
<html lang=ru>
  <!-- тег который содержит все вспомогательные данные о HTML документе:
       - заголовок, описание, SEO-информация, подключение стилей и шрифтов, скриптов, meta-информация.
       Данные указанные внутри этого тега не отрисовываются на странице-->
  <head>
    <meta charset=UTF-8 />
    <title>Моя первая страница</title>
  </head>

  <!-- тег, который содержит всю разметку HTML документа. 
       Именно эта разметка будет отображаться в браузере -->
  <body></body>
</html>
`,
    ],
  ],
  [
    [`4. Что такое семантика? Какие семантическиетэги вы знаете?`],
    [
      `Семантика в контексте HTML - это использование правильных тегов, описывающих содержание контента внутри себя. Семантический тег - это тег который носит смысловое значение. То есть обладает каким-то пояснением своего предназначения. Другими словами каждому элементу веб-страницы соответствует правильное смысловое значение.

<article>
<aside>
<details>
<figcaption>
<figure>
<footer>
<header>
<main>
<mark>
<nav>
<section>
<summary>
<time>`,
    ],
  ],
  [
    [`5. Что описывается в тэге <head>?`],
    [
      `<head>
  <!-- Метаданные — данные, которые описывают данные.
  Многие типы <meta> больше не используются. Так, поисковые системы больше не используют данные из элемента <meta type=keywords content=ваши, ключевые, слова, введите, здесь>
   -->
  <!-- кодировка документа -->
  <meta charset=UTF-8 />
  <!-- Основной заголовок HTML-страницы -->
  <title>Моя первая страница</title>
  <!-- указание автора страницы  -->
  <meta name=author content=Крис Миллс />
  <!-- краткое описание её содержимого  -->
  <meta
    name=description
    content=Задача MDN — в том, чтобы обучить
новичков всему тому, что нужно им для разработки веб-сайтов и приложений.
  />
  <!-- Подключение иконок -->
  <link
    rel=shortcut icon
    href=https://developer.mozilla.org/static/img/favicon32.png
  />
  <!-- Подключение CSS -->
  <link rel=stylesheet href=my-css-file.css />
  <!-- Подключение JavaScript -->
  <script src=my-js-file.js></script>
  <!-- Meta-тег viewport сообщает браузеру о том, как именно обрабатывать размеры страницы, и изменять её масштаб -->
  <meta name=viewport content=width=device-width, initial-scale=1 />
</head>
`,
    ],
  ],
  [
    [`6. Разница между <script>, <script async> и <script defer>?`],
    [
      `Когда браузер загружает HTML и доходит до тега <script>...</script>, он не может продолжать строить DOM. Он должен сначала выполнить скрипт. То же самое происходит и с внешними скриптами html<script src=...></script>: браузер должен подождать, пока загрузится скрипт, выполнить его, и только затем обработать остальную страницу.

Это ведёт к двум важным проблемам:

- Скрипты не видят DOM-элементы ниже себя, поэтому к ним нельзя добавить обработчики и т.д.
- Если вверху страницы объёмный скрипт, он «блокирует» страницу. Пользователи не видят содержимое страницы, пока он не загрузится и не запустится:

**_defer_**

Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.

Отложенные с помощью defer скрипты сохраняют порядок относительно друг друга, как и обычные скрипты.

**_async_**

Атрибут async означает, что скрипт абсолютно независим:

- Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.
- Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:
- Остальные скрипты не ждут async, и скрипты c async не ждут другие скрипты.

Так что если у нас есть несколько скриптов с async, они могут выполняться в любом порядке. То, что первое загрузится – запустится в первую очередь:`,
    ],
  ],
  [
    [`7. Область веб-страницы viewport?`],
    [
      `Viewport - это видимая пользователю область веб-страницы, то, что может увидеть пользователь, не прибегая к прокрутке.

Meta-тег viewport сообщает браузеру о том, как именно обрабатывать размеры страницы, и изменять её масштаб. Этот тег необходимо добавлять в секцию HEAD.

html
<meta name=viewport content=width=device-width, initial-scale=1 />


Meta-тег viewport может иметь следующие атрибуты, указанные через запятую (,):

- width – ширина области просмотра.
- height – высота области просмотра.
- initial-scale – начальный масштаб страницы.
- user-scalable – доступность масштабирования страницы пользователем.
- minimum-scale– минимальный масштаб области просмотра.
- maximum-scale – максимальный масштаб области просмотра.
`,
    ],
  ],
  [
    [`1. Способы добавления CSS на страницу?`],
    [
      `.
- Внешняя таблица стилей
       <link rel=stylesheet href=css/style.css>
  
- Внутренние стили
  bash
     <style>
     h2 {
     color: red;
     }
     </style>
  
- Встроенные стили
  bash
     <p style=font-weight: bold; color: red;>Обратите внимание на этот текст.</p>
  `,
    ],
  ],
  [
    [`2. Единицы измерения CSS`],
    [
      `.
- px – абсолютные пиксели, к которым привязаны и потому не нужны mm, cm, pt и pc. Используется для максимально конкретного и точного задания размеров.
- em – задаёт размер относительно шрифта родителя, используется там, где нужно упростить масштабирование компоненты.
- rem – задаёт размер относительно шрифта <html>, используется для удобства глобального масштабирования: элементы которые планируется масштабировать, задаются в rem, а JS меняет шрифт у <html>.
- % – относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, без него никуда, но надо знать, относительно чего он считает проценты.
- vw, vh, vmin, vmax – относительно размера окна браузера.
`,
    ],
  ],
  [
    [`3. Значения свойства display?`],
    [
      `Значений много, но самыми популярными являются:

- none
  - Блочные элементы располагаются один над другим, вертикально
  - Элемент не показывается, вообще. Как будто его и нет.
- block
  - Блочные элементы располагаются один над другим, вертикально
  - Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.
- inline
  - Элементы располагаются на той же строке, последовательно.
  - Ширина и высота элемента определяются по содержимому. Поменять их нельзя.
- inline-block
  - Располагается в строке.
  - Размер устанавливается по содержимому.
  - Элемент всегда прямоугольный
  - Работают свойства width/height.
- flex
  - Flexbox позволяет удобно управлять дочерними и родительскими элементами на странице, располагая их в необходимом порядке.
`,
    ],
  ],
  [
    [`4. Подробнее о Flex box`],
    [
      `[подробная статья](https://wp-kama.ru/id_8045/flex-v-css.html#flex-flow-direction-wrap)`,
    ],
  ],
  [
    [`5. свойство Position`],
    [
      `.
- static
  Это значение позволяет элементу находиться в обычном его состоянии, расположенном на своём месте в документе. Свойства top, right, bottom, left и z-index не применяются к данному элементу. Это значение по умолчанию.
- relative
  Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно себя на основе значений top, right, bottom и left. Смещение не влияет на положение любых других элементов; таким образом, пространство, заданное для элемента в макете страницы, такое же, как если бы позиция была static.

- absolute
  Элемент удаляется из обычного потока документов, и для элемента в макете страницы не создаётся пробела. Он расположен относительно его ближайшего относительно позиционированного предка, если таковой имеется; в противном случае он помещается относительно исходного содержащего блока. Его конечная позиция определяется значениями top, right, bottom, и left.

- fixed
  Элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство. Он позиционируется относительно исходного содержащего блока, установленного viewport, за исключением случаев, когда один из его предков имеет свойство transform, perspective, или filter, установленное на что-то иное, кроме none (см. CSS Transforms Spec), и в этом случае этот предок ведёт себя как содержащий блок. (Обратите внимание, что существуют несогласованности браузера с perspective и filter, способствующими содержанию формирования блоков.) Его конечная позиция определяется значениями top, right, bottom и left.

- sticky //ToDo
  Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока), включая элементы, связанные с таблицей, на основе значений top, right, bottom, и left. Смещение не влияет на положение любых других элементов.
  Это значение всегда создаёт новый контекст наложения. Обратите внимание, что липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при overflow равном hidden, scroll, auto или overlay), даже если тот не является ближайшим фактически прокручивающим предком. Это эффективно препятствует любому «липкому» поведению
`,
    ],
  ],
  [
    [`6. Что такое блочная-модель?`],
    [
      `В HTML-документе каждому элементу на странице соответствует прямоугольная область (бокс или блок). Движок рендеринга в браузере определяет размеры и положение боксов на странице, а также их свойства вроде цвета, фоновой картинки для того, чтобы отобразить их на экране.

В языке CSS есть специальная боксовая модель (также блоковая модель или блочная модель, англ. box model), которая описывает, из чего состоит бокс и какие свойства влияют на его размеры. В ней у каждого бокса есть 4 области: margin (внешние отступы), border (рамка), padding (внутренние поля), и content (контент или содержимое).`,
    ],
  ],
  [
    [`7. Cвойство box-sizing.`],
    [
      `По умолчанию в блоковой модели CSS ширина и высота, которую вы задаёте элементу применяется только для контента элемента. Если у элемента есть граница или внутренний отступ, то они добавляются к ширине и высоте, чтобы получить отображаемый на экране размер.

Свойство box-sizing может изменять это поведение:

content-box даёт стандартное поведение свойства box-sizing. Если вы выставите элементу ширину 100 пикселей, то ширина его контента будет 100 пикселей, а ширина границ и внутренних отступов при рендере будет добавлена к финальной ширине, делая элемент шире ста пикселей.
border-box говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. Обычно это упрощает работу с размерами элементов.
`,
    ],
  ],
  [
    [`8. Что такое псевдокласс?`],
    [
      `Псевдокласс — это селектор, который выбирает элементы, находящиеся в специфическом состоянии, например, они являются первым элементом своего типа, или на них наведён указатель мыши. Они обычно действуют так, как если бы вы применили класс к какой-то части вашего документа, что часто помогает сократить избыточные классы в разметке и даёт более гибкий, удобный в поддержке код.

Псевдоклассы — это ключевые слова, которые начинаются с двоеточия :

| Селектор           | Описание                                                                                         |
| ------------------ | ------------------------------------------------------------------------------------------------ |
| :active            | ользователь активирует (например, щёлкает мышью) элемент.                                        |
| :checked           | Соответствует переключателю или флажку в выбранном состоянии.                                    |
| :disabled          | Соответствует элементам пользовательского интерфейса, которые находятся в отключённом состоянии. |
| :first-child       | Соответствует элементу, который является первым среди других дочерних элементов одного предка.   |
| :focus             | Соответствует элементу, имеющему фокус.                                                          |
| :hover             | Соответствует элементу, на который наведён курсор мыши.                                          |
| :invalid           | Соответствует элементу, например <input>, в недопустимом состоянии.                            |
| :visited           | Соответствует посещённым ссылкам.                                                                |
| :placeholder-shown | Соответствует элементу input, который показывает текст-заполнитель.          `,
    ],
  ],
  [
    [`9. Что такое псевдоэлемент?`],
    [
      `Псевдоэлементы ведут себя сходным образом, однако они действуют так, как если бы вы добавили в разметку целый новый HTML-элемент, а не применили класс к существующим элементам. Псевдоэлементы начинаются с двойного двоеточия ::.

| Селектор       | Описание                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------- |
| ::after        | Соответствует элементу, который допускает стилизацию и появляется после текущего содержимого порождающего элемента. |
| ::before       | Соответствует элементу, который допускает стилизацию и появляется перед текущим содержимым порождающего элемента.   |
| ::first-letter | Соответствует первой букве элемента.                                                                                |
| ::first-line   | Соответствует первой строке содержимого порождающего элемента.                                                      |`,
    ],
  ],
  [
    [`10. Что такое специфичность`],
    [
      `Специфичность - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее соответствуют элементу и, следовательно, будут применены.

| Селектор     | Вес  | Описание селектора     |
| ------------ | ---- | ---------------------- |
| style=     | 1000 | инлайновый стиль       |
| #id          | 100  | идентификатор          |
| .class       | 10   | класс                  |
| :hover       | 10   | псевдокласс            |
| [attr=value] | 10   | атрибут                |
| LI           | 1    | элемент                |
| ::before     | 1    | псевдоэлемент          |
| \*           | 0    | универсальный селектор |

**_Важное исключение из правил - !important_**

Когда при объявлении стиля используется модификатор !important, это объявление получает наивысший приоритет среди всех прочих объявлений. Хотя технически модификатор !important не имеет со специфичностью ничего общего, он непосредственно на неё влияет. Поскольку !important усложняет отладку, нарушая естественное каскадирование ваших стилей, он не приветствуется и следует избегать его использования. Если к элементу применимы два взаимоисключающих стиля с модификатором !important, то применён будет стиль с большей специфичностью.
`,
    ],
  ],
  [
    [`11. Что Grid CSS?`],
    [
      `[Видео кратко за 13 минут](https://www.youtube.com/watch?v=MEOR2b69Pl4)
`,
    ],
  ],
];

let randomData = data.sort(() => 0.5 - Math.random());

const elQues = document.querySelector('.ques');
const elNQues = document.querySelector('.n-ques');
const elAnswer = document.querySelector('.answer');

let i = 0;

elNQues.innerHTML = i + 1;
elQues.innerHTML = randomData[i][0];
elAnswer.innerHTML = randomData[i][1];

function nextQues() {
  i += 1;

  if (i > randomData.length) i = 0;

  elNQues.innerHTML = i + 1;
  elQues.innerHTML = randomData[i][0];
  elAnswer.innerHTML = randomData[i][1];

  elAnswer.style.display = 'none';
}

function backQues() {
  i += -1;

  if (i < 0) i = 0;

  elNQues.innerHTML = i + 1;
  elQues.innerHTML = randomData[i];
  elAnswer.innerHTML = randomData[i][1];
}

function showAnswer() {
  elAnswer.style.display = 'block';
}
